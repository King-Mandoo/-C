2022. 05. 05.

🟡 스택

🟠 스택의 이해
 
  --> 스택은 한쪽 끝이 막힌 터널과 같은 데이터 구조로, 가장 나중에 들어간 것이 가장 먼저 나오는 LIFO (Last In First Out) 구조로 되어 있다.
      즉, 들어가는 순서는 A -> B -> C 이지만 나오는 순서는 C -> B -> A 이다.
      
      터널 안에 자동차 3대가 들어갔을 때 다음에 들어갈 자동차의 위치를 'top'이라고 한다.
      만약 자동차 C가 빠져나간다면 top의 위치가 자동차 C로 바뀔 것이다.
      즉, top은 현재 스택에서 다음에 들어갈 데이터의 위치를 가리킨다.
      또한 데이터를 넣는 것을 '푸시(push)', 빼는 것을 '팝(pop)'이라고 한다.
      
 #include <stdio.h>

int main()
{
	char stack[5];
	int top = 0;

	char carName = 'A';
	int select = 9;

	while (select != 3)
	{
		printf("<1> 차 추가 <2> 차 빼기 <3> 끝 : ");
		scanf("%d", &select);

		switch (select)
		{
		case 1: 
			if (top >= 5)
			{
				printf("더 이상 추가 불가능!\n");
			}
			else
			{
				stack[top] = carName++;
				printf("%c차 추가!\n", stack[top]);
				top++;
			}
			break;

		case 2:
			if (top <= 0)
			{
				printf("더 이상 빼기 불가능!\n");
			}
			else
			{
				top--;
				printf("%c차 빼기!\n", stack[top]);
				stack[top] = carName--;
			}
			break;

		case 3:
			printf("종료\n");
			break;

		default:
			printf("다시 입력\n");
			break;
		}
	}

	return 0;
}



🟡 메모리와 주소

🟠 정수형 변수의 메모리 할당

  --> 정수형 변수를 선언하면 임의의 위치에 4바이트가 자리를 잡는다.
      변수가 위치하는 곳을 '주소'라고 하며, 변수의 주소를 알리면 변수 앞에 &를 붙인다.
      
#include <stdio.h>

int main()
{
	int a = 100;
	int b = 200;
 
	printf("%d\n", &a);        <--  변수 a의 주소를 출력
	printf("%d", &b);         <--  변수 b의 주소를 출력

	return 0;
}


🟠 정수형 배열의 메모리 할당

  -->  int aa[3] = { 10, 20, 30 }
       변수는 연속된 메모리에 할당되지 않을 수도 있지만, 배열의 경우에는 주소에 연속해서 할당되는 특징이 있다.
       
       &aa[0] = 1031
       &aa[1] = 1035
       &aa[2] = 1039
       
       그리고 배열 이름 aa는 전체 배열의 주소를 의미한다. 즉 aa는 1031 번지를 의미한다.
       이때 주의할 점은, aa[0]의 주소는 &aa[0]으로 표현하지만 
       배열 이름 aa 자체가 주소를 의미하기 때문에 배열 aa의 주소를 구할 때는 &aa와 같이 표현하지 않고 단순히 aa로 표현한다는 것이다.

#include <stdio.h>

int main()
{
	int aa[3] = { 100,200,300 };

	printf("%d\n", &aa[0]);
	printf("%d\n", &aa[1]);
	printf("%d\n", &aa[2]);
	printf("%d", aa);

	return 0;
}

출력결과: 391117432
          391117436   <-- 정수형 배열이므로 4바이트 증가
          391117440   <-- 4바이트 증가
          391117432   <-- &aa[0]과 똑같은 값을 출력
          
  ---------------------------------------------------
  
#include <stdio.h>

int main()
{
	char ss[4] = {  'A','B','C' };

	printf("%d\n", &ss[0]);
	printf("%d\n", &ss[1]);
	printf("%d\n", &ss[2]);
	printf("%d", ss);              <-- %d를 %s로 바꾸면 "ABC"로 출력한다.

	return 0;
}          
          
출력결과: 857536004  
          857536005   <-- 문자형 배열이므로 1바이트 증가
          857536006   <-- 1바이트 증가
          857536004   <-- &ss[0]과 같은 값을 출력
          
          
          🎈🎈 배열 이름은 변수가 아닌 주소 자체이다...!!
          
                             aa+1에서 +1은 단순히 1을 더하라는 의미가 아니라 '배열 aa의 위치에서 한 칸 건너뛰라'는 의미이다.
#include <stdio.h>

int main()
{
	int aa[4] = { 100,200,300 };

	printf("%d\n", &aa[0]);
	printf("%d\n", &aa[1]);
	printf("%d\n", &aa[2]);
	printf("%d\n", aa);             
	printf("%d\n", aa + 1);    <-- &aa[1] 와 aa+1은 같은 값을 가진다.   // aa[x] 와 aa+x 는 동일한 주소이다.
	printf("%d\n", aa + 2);    <-- &aa[2] 와 aa+2는 같은 값을 가진다.

	return 0;
}

출력결과: 1944057160
          1944057164
          1944057168
          1944057160
          1944057164
          1944057168
