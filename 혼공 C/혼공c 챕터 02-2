10진수: 0 1 2 3 4 5 6 7 8 9  /  10 11 12 13 14 15 16 17 18 19 / 20 21 22 23 ...
 8진수: 0 1 2 3 4 5 6 7  /  10 11 12 13 14 15 16 17  /  20 21 22 23 ...
16진수: 0 1 2 3 4 5 6 7 8 9 0A 0B 0C 0D 0E 0F  /  10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F / 20 21 22 23 ... 

#include <stdio.h>

int main(void)                                                                    
{                                                                                           출력결과: 
	printf("%d\n", 12);        ---> 10진수 정수 상수 출력                                           12 
	printf("%d\n", 014);       --->  8진수 정수 상수 출력                                           12
	printf("%d\n", 0xc);       ---> 16진수 정수 상수 출력                                           12
}

//8진수는 숫자 앞에 0(영),  16진수는 0x(영엑스)를 붙여 구분한다.

10진수: 0 1 2 3 4 5 6 7 8 9  /  10 11 12 13 14 15 16 17 18 19 / 20 21 22 23 ...
 8진수: 0 1 2 3 4 5 6 7  /  010 011 012 013 014 015 016 017  /  020 021 022 023 ...
16진수: 0x0 0x1 0x2 0x3 0x4 0x5 0x6 0x7 0x8 0x9 0xa 0xb 0xc 0xd 0xe 0xf  /  0x10 0x11 0x12 0x13 0x14 0x15 0x16 0x17 0x18 0x19 0x1a 0x1b 0x1c 0x1d 0x1e 0x1f  /  0x20 ... 

#include <stdio.h>

int main(void) 
{                                                                                        출력결과: 
	printf("%o\n", 12);   ---->  12를 8진수로 출력 ( %o 사용 )                                         14
	printf("%x\n", 12);   ---->  12를 16진수 소문자로 출력 ( %x 사용 )                                  c
	printf("%X\n", 12);   ---->  12를 16진수 대문자로 출력 ( %X 사용 )                                  C
}

//   %o은 8진수로 변환해준다.
//   %x는 16진수 소문자로 변환해준다.
//   %X는 16진수 대문자로 변환해준다.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

0.0000314   <--  소수점 형태

3.14 x 10^-5      <---  지수 형태         >>>>>>>     3.14e-5       <--- c언어 표기법
0.314 x 10^-4      <---  지수 형태         >>>>>>>     0.314e-4     <--- c언어 표기법                                    
31.4 x 10^-6      <---  지수 형태         >>>>>>>     31.4e-6       <--- c언어 표기법

// e는 밑수 10을 의미하며 대문자로 쓸 수도 있다.  즉, 3.14e-5나 31.4E-5는 같은 의미라는 뜻이다.

*밑수 : 일반 수학 용어로 어떤 수치를 [a×bⁿ]과 같은 형식으로 표기할 때의 b를 가리키는 말.

#include <stdio.h>

int main(void)
{
	printf("%.1lf\n", 1e6);             ---->  1000000.0 으로 출력           // 49행과 50행을 보면 printf 함수는 출력 값을 지수 형태로 사용해도 기본적으로 소수점 형태로 출력한다.
	printf("%.7lf\n", 3.14e-5);         ---->  0.0000314 로 출력
	printf("%le\n", 0.0000314);         ---->  3.140000e-05 로 출력         // 51행과 52행 처럼 지수 형태로 출력하려면  %le 변환 문자를 사용해야한다.
	printf("%.2le\n", 0.0000314);       ---->  3.14e-05 로 출력

	return 0;
}

지수 형태는 지수 값의 크기에 따라 무수히 많은 방법으로 표현이 가능하다.
그중 소수점 앞에 0이 아닌 유효 숫자 한 자리를 사용하여 지수 형태로 바꾼 것을 "정규화 normalization 표기법" 이라고 한다.
printf 함수가 실수를 지수 형태로 출력할 때는 기본적으로 정규화 표기법을 사용한다.

*50행의 printf("%.7lf\n", 3.14e-5);  이 문장에서 %.7lf를 사용하는 이유가 무엇일까?
:  %lf 변환 문자로 실수로 출력하면 소수점 이하 6자리까지만 출력된다. 하지만 이 문장에서 출력되어야 하는 소수점 자릿수는 총 7자리이다. 
   기본 출력 방식을 따르면 소수점 이하 6자리까지만 출력되어 0.000031이 출력되므로  %.7lf를 사용하여 소수점 이하 7자리까지 출력하도록 했다.
   
   이렇게 출력할 숫자가 많을 때는 소수점 이하 자릿수를 충분히 잡아서 유효 숫자가 잘리지 않도록 해야한다.

*51행 printf("%le\n", 0.0000314);  이 문장이    -->    3.140000e-05 로 출력되는 이유 
:  위의 이유가 마찬가지다 소숫점 6자리까지 출력된다.
   따라서
   52행에서는  %.2le를 사용해서 3.14e-05로 출력을 했다.
   
   ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#include <stdio.h>

int main(void)
{
	printf("%c\n", 'A');                            // 문자 상수 출력
	printf("%s\n", "A");                            // 문자열 상수 출력
	printf("%c은 %s입니다.\n", '1', "first");        // 문자(%c)와 문자열(%s)을 함께 출력

	return 0;
}
 
문자 상수는 ''(작은 따옴표)     ----->   문자는 %c 변환문자를 사용
문자열 상수는 ""(큰 따옴표)     -----> 문자열은 변환문자 없이 출력이 가능하지만 보통 %s를 사용한다.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

편집기에 코드를 입력하면 이 코드는 모두 컴퓨터가 이해하는 형태의 아스키 코드 값으로 저장된다.

*아스키 코드란?
아스키 코드는 사람이 사용하는 기호를 컴퓨터 안에서 표현하는 방법에 대해 약속한 것이다.
예를 들어 소스 파일에 A라는 문자를 사용하면 컴퓨터는 8개의 비트를 01000001과 같은 상태로 저장한다. 또한 컴푸터에 01000001과 같은 비트 열이 있으면 모니터 화면에 A라는 문자를 보여준다.

예를 들어 10 + 20;을 입력했다면 1, 0, +, 2, 0, ;이 모두 하나의 문자로 저정이 된다. 컴파일 과정이 없으면 코드가 컴퓨터에서 실행되지 않는 이유가 바로 이 때문이다.
컴퓨터에서는 +를 '덧셈'으로 받아들이지 않고 그저 '+'문자이고, 10과 20 또한 연산 가능한 값이 아니라 문자이다.

코드가 컴파일러를 거쳐 컴파일되어야 비로소 연산자는 명령어가 되고 상수는 연산이 가능한 형태로 바뀐다. 상수는 종류에 따라 각기 다른 형태로 바뀐다.

컴퓨터는 모든 데이터를 비트(bit)로 변환한다. 
1비트는 0과 1, 이렇게 두 개의 값을 갖는다. 비트가 8개면 1바이트(byte)라고 한다. 2^8은 256이니 1바이트의 값은 256가지이다.

결국 데이터의 크기가 크면 프로그램에서 사용할 수 있는 값의 크기가 커진다. 하지만 데이터의 크기가 커질수록 메모리나 연산에 부담을 주게 된다.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

정수 상수를 컴파일하면 4바이트로 표현한다.
실수는 8바이트로 표현한다.             (책 p.43 참고)

10과 10.0의 차이를 우리는 느끼지 못하지만, 컴퓨터는 이 둘을 다르게 인식하고 처리한다.
따라서 어떤 상수를 쓰느냐에 따라 실행 속도나 정확도에 차이가 날 수 있다.
정수는 가장 빠르고 정확하게 연산될 수 있는 형태이므로 프로그래밍할 때 가능하면 정수 상수를 사용하는 것이 좋다.

나머지는 책 p.44 ~ p.48 확인하기. 꼭. 꼭. 꼭.

----------------------------------------------------------------------------------정리-----------------------------------------------------------------------------------------

10은 정수 상수, 10.0은 실수 상수, 'a'는 문자 상수, "a"는 문자열 상수이다.

정수 상수의 양수는 4바이트 크기의 2진수, 음수는 2의 보수로 컴파일된다.  (p.45~46 확인)

실수는 IEEE 754 표준의 double 형식에 따라 번역되며, 첫 비트는 부호 비트,이후 11개 비트는 지수부, 나머지 52비트는 소수부를 나타낸다. (p.46~47 확인)

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

*연습풀이

#include <stdio.h>

int main(void)
{
	printf("학번 : %d\n", 32165);
	printf("이름 : %s\n", "홍길동");
	printf("학점 : %c\n", 'A');

	return 0;
}
